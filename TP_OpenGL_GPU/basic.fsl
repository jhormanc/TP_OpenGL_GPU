#version 430

layout(location = 3) uniform vec3 cam_pos;
layout(location = 4) uniform vec3 light_pos;
uniform sampler2D texture_sampler[3];
uniform sampler2D shadow_map;

out vec4 color_out;

in vec4 pt_out;
in vec3 normal_out;
in vec2 uv_out;
flat in int num_texture;
in vec4 shadow_coord;

vec4 light_color = vec4(1, 1, 1, 1);
vec4 diffus = vec4(1, 1, 1, 1);
vec4 specular = vec4(1, 1, 1, 1);
float light_power = 10;
float ambient_power = 0.1;

void main()
{
	vec3 pos = (pt_out / pt_out.w).xyz;
	// Normal of the computed fragment, in camera space
	vec3 n = normalize(normal_out);

	// Direction of the light (from the fragment to the light)
	vec3 l = normalize(light_pos - pos);

	// Eye vector (towards the camera)
	vec3 e = normalize(pos - cam_pos);

	// Direction in which the triangle reflects the light
	vec3 r = reflect(-l, n);

	// Cosine of the angle between the Eye vector and the Reflect vector, clamped to 0
	//  - Looking into the reflection -> 1
	//  - Looking elsewhere -> < 1
	float cos_alpha = clamp(dot(e, r), 0, 1);

	// Cosine of the angle between the normal and the light direction, clamped above 0
	//  - light is at the vertical of the triangle -> 1
	//  - light is perpendicular to the triangle -> 0
	//  - light is behind the triangle -> 0
	float cos_theta = clamp(dot(n, l), 0, 1);
	float dist = distance(pos, light_pos);

	vec4 color;

	if(num_texture >= 0)
		color = texture(texture_sampler[num_texture], uv_out).rgba;
	else
		color = vec4(0.7, 0.7, 0.7, 1);

	vec4 ambient = vec4(ambient_power, ambient_power, ambient_power, 1) * color;
	diffus = color;
	specular = color;

	vec4 coord = shadow_coord / shadow_coord.w;
	
	// Used to lower moiré pattern and self-shadowing
	coord.z -= 0.0005;

	float distFromLight = texture(shadow_map, coord.xy).z;
		
	float shadow = 1.0;
	//if (shadow_coord.w > 0.0)
	 	shadow = distFromLight < coord.z ? 0.5 : 1.0;

	vec4 c_out = ambient // Ambient : simulates indirect lighting
	+ shadow * diffus * light_color * light_power * cos_theta / (dist * dist) // Diffuse : "color" of the object
	+ shadow * specular * light_color * light_power * pow(cos_alpha, 5) / (dist * dist); // Specular : reflective highlight, like a mirror

	// Gamma correction
	c_out.x = pow(c_out.x, 1 / 2.2);
	c_out.y = pow(c_out.y, 1 / 2.2);
	c_out.z = pow(c_out.z, 1 / 2.2);

	//color_out = texture(shadow_map, coord.xy).rgba;
	color_out = c_out;
}